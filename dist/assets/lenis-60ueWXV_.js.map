{"version":3,"file":"lenis-60ueWXV_.js","sources":["../../node_modules/lenis/dist/lenis.mjs"],"sourcesContent":["// package.json\nvar version = \"1.3.17\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchend\",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for 'touchmove' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for 'wheel' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit(\"scroll\", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar defaultEasing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  _rafId = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don't need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it's used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration,\n    // in seconds\n    easing,\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false,\n    // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false,\n    naiveDimensions = __experimental__naiveDimensions,\n    stopInertiaOnNavigate = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      naiveDimensions,\n      stopInertiaOnNavigate\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.addEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.options.wrapper.addEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoToggle) {\n      this.checkOverflow();\n      this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n        passive: true\n      });\n    }\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      \"scroll\",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.removeEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this._rafId) {\n      cancelAnimationFrame(this._rafId);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  onScrollEnd = (e) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n        e.stopPropagation();\n      }\n    }\n  };\n  dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent(\"scrollend\", {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true\n        }\n      })\n    );\n  };\n  get overflow() {\n    const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n    return getComputedStyle(this.rootElement)[property];\n  }\n  checkOverflow() {\n    if ([\"hidden\", \"clip\"].includes(this.overflow)) {\n      this.internalStop();\n    } else {\n      this.internalStart();\n    }\n  }\n  onTransitionEnd = (event) => {\n    if (event.propertyName.includes(\"overflow\")) {\n      this.checkOverflow();\n    }\n  };\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: \"instant\" });\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: \"instant\" });\n    }\n  }\n  onClick = (event) => {\n    const path = event.composedPath();\n    const anchorElements = path.filter(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute(\"href\")\n    );\n    if (this.options.anchors) {\n      const anchor = anchorElements.find(\n        (node) => node.getAttribute(\"href\")?.includes(\"#\")\n      );\n      if (anchor) {\n        const href = anchor.getAttribute(\"href\");\n        if (href) {\n          const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n          const target = `#${href.split(\"#\")[1]}`;\n          this.scrollTo(target, options);\n        }\n      }\n    }\n    if (this.options.stopInertiaOnNavigate) {\n      const internalLink = anchorElements.find(\n        (node) => node.host === window.location.host\n      );\n      if (internalLink) {\n        this.reset();\n      }\n    }\n  };\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit(\"virtual-scroll\", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes(\"touch\");\n    const isWheel = event.type.includes(\"wheel\");\n    this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n    const isClickOrTap = deltaX === 0 && deltaY === 0;\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n    if (isClickOrTap || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, { deltaX, deltaY }))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = \"native\";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === \"both\") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === \"horizontal\") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const isSyncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === \"touchend\";\n    const hasTouchInertia = isTouchEnd;\n    if (hasTouchInertia) {\n      delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === \"native\") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      if (!this.isStopped) {\n        this.isScrolling = \"native\";\n      }\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty(\"overflow\");\n      return;\n    }\n    this.internalStart();\n  }\n  internalStart() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n    this.emit();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty(\"overflow\", \"clip\");\n      return;\n    }\n    this.internalStop();\n  }\n  internalStop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n    this.emit();\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time) => {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf);\n    }\n  };\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    programmatic = true,\n    // called from outside of the class\n    lerp: lerp2 = programmatic ? this.options.lerp : void 0,\n    duration = programmatic ? this.options.duration : void 0,\n    easing = programmatic ? this.options.easing : void 0,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\", \"#\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n        if (!node) {\n          if (target === \"#top\") {\n            target = 0;\n          } else {\n            console.warn(\"Lenis: Target not found\", target);\n          }\n        }\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n        const distance = target - this.animatedScroll;\n        if (distance > this.limit / 2) {\n          target = target - this.limit;\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit;\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  checkNestedScroll(node, { deltaX, deltaY }) {\n    const time = Date.now();\n    const cache = node._lenis ??= {};\n    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n    const gestureOrientation = this.options.gestureOrientation;\n    if (time - (cache.time ?? 0) > 2e3) {\n      cache.time = Date.now();\n      const computedStyle = window.getComputedStyle(node);\n      cache.computedStyle = computedStyle;\n      const overflowXString = computedStyle.overflowX;\n      const overflowYString = computedStyle.overflowY;\n      hasOverflowX = [\"auto\", \"overlay\", \"scroll\"].includes(overflowXString);\n      hasOverflowY = [\"auto\", \"overlay\", \"scroll\"].includes(overflowYString);\n      cache.hasOverflowX = hasOverflowX;\n      cache.hasOverflowY = hasOverflowY;\n      if (!hasOverflowX && !hasOverflowY) return false;\n      if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n      if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n      scrollWidth = node.scrollWidth;\n      scrollHeight = node.scrollHeight;\n      clientWidth = node.clientWidth;\n      clientHeight = node.clientHeight;\n      isScrollableX = scrollWidth > clientWidth;\n      isScrollableY = scrollHeight > clientHeight;\n      cache.isScrollableX = isScrollableX;\n      cache.isScrollableY = isScrollableY;\n      cache.scrollWidth = scrollWidth;\n      cache.scrollHeight = scrollHeight;\n      cache.clientWidth = clientWidth;\n      cache.clientHeight = clientHeight;\n    } else {\n      isScrollableX = cache.isScrollableX;\n      isScrollableY = cache.isScrollableY;\n      hasOverflowX = cache.hasOverflowX;\n      hasOverflowY = cache.hasOverflowY;\n      scrollWidth = cache.scrollWidth;\n      scrollHeight = cache.scrollHeight;\n      clientWidth = cache.clientWidth;\n      clientHeight = cache.clientHeight;\n    }\n    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n      return false;\n    }\n    if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY))\n      return false;\n    if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX))\n      return false;\n    let orientation;\n    if (gestureOrientation === \"horizontal\") {\n      orientation = \"x\";\n    } else if (gestureOrientation === \"vertical\") {\n      orientation = \"y\";\n    } else {\n      const isScrollingX = deltaX !== 0;\n      const isScrollingY = deltaY !== 0;\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = \"x\";\n      }\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = \"y\";\n      }\n    }\n    if (!orientation) return false;\n    let scroll, maxScroll, delta, hasOverflow, isScrollable;\n    if (orientation === \"x\") {\n      scroll = node.scrollLeft;\n      maxScroll = scrollWidth - clientWidth;\n      delta = deltaX;\n      hasOverflow = hasOverflowX;\n      isScrollable = isScrollableX;\n    } else if (orientation === \"y\") {\n      scroll = node.scrollTop;\n      maxScroll = scrollHeight - clientHeight;\n      delta = deltaY;\n      hasOverflow = hasOverflowY;\n      isScrollable = isScrollableY;\n    } else {\n      return false;\n    }\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n    return willScroll && hasOverflow && isScrollable;\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.options.autoToggle) className += \" lenis-autoToggle\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport {\n  Lenis as default\n};\n//# sourceMappingURL=lenis.mjs.map"],"names":["clamp","min","input","max","Math","Animate","isRunning","value","from","to","currentTime","lerp","duration","easing","onUpdate","advance","deltaTime","this","completed","linearProgress","easedProgress","x","y","lambda","t","exp","damp","round","stop","fromTo","lerp2","onStart","Dimensions","constructor","wrapper","content","autoResize","debounce","debounceValue","debouncedResize","callback","delay","timer","args","context","clearTimeout","setTimeout","apply","resize","Window","window","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","width","height","scrollHeight","scrollWidth","destroy","disconnect","removeEventListener","onWrapperResize","onContentResize","innerWidth","innerHeight","clientWidth","clientHeight","limit","Emitter","events","emit","event","callbacks","i","length","on","cb","push","filter","off","LINE_HEIGHT","listenerOptions","passive","VirtualScroll","element","options","wheelMultiplier","touchMultiplier","onWindowResize","onWheel","onTouchStart","onTouchMove","onTouchEnd","touchStart","lastDelta","emitter","clientX","clientY","targetTouches","deltaX","deltaY","deltaMode","defaultEasing","pow","Lenis","_isScrolling","_isStopped","_isLocked","_preventNextNativeScrollEvent","_resetVelocityTimeout","_rafId","isTouching","time","userData","lastVelocity","velocity","direction","targetScroll","animatedScroll","animate","dimensions","virtualScroll","document","documentElement","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaExponent","infinite","orientation","gestureOrientation","prevent","overscroll","autoRaf","anchors","autoToggle","allowNestedScroll","__experimental__naiveDimensions","naiveDimensions","stopInertiaOnNavigate","lenisVersion","updateClassName","actualScroll","onNativeScroll","onScrollEnd","capture","onClick","onPointerDown","onVirtualScroll","checkOverflow","rootElement","onTransitionEnd","requestAnimationFrame","raf","cleanUpClassName","cancelAnimationFrame","e","CustomEvent","isScrolling","stopPropagation","dispatchScrollendEvent","dispatchEvent","bubbles","detail","lenisScrollEnd","overflow","property","isHorizontal","getComputedStyle","includes","internalStop","internalStart","propertyName","setScroll","scroll","scrollTo","left","behavior","top","anchorElements","composedPath","node","HTMLAnchorElement","getAttribute","anchor","find","href","target","split","host","location","reset","button","data","ctrlKey","lenisStopPropagation","isTouch","type","isWheel","isClickOrTap","isStopped","isLocked","isUnknownGesture","slice","indexOf","HTMLElement","hasAttribute","checkNestedScroll","cancelable","preventDefault","delta","abs","isSyncTouch","hasTouchInertia","sign","programmatic","lastScroll","start","style","removeProperty","setProperty","offset","immediate","lock","onComplete","force","querySelector","nodeType","wrapperRect","getBoundingClientRect","rect","distance","preventNextNativeScrollEvent","Date","now","cache","_lenis","hasOverflowX","hasOverflowY","isScrollableX","isScrollableY","computedStyle","overflowXString","overflowX","overflowYString","overflowY","maxScroll","hasOverflow","isScrollable","scrollLeft","scrollTop","scrollX","scrollY","n","d","progress","isSmooth","className","trim","replace"],"mappings":"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","x_google_ignoreList":[0]}